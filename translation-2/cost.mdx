---
title: 'Cost Optimization'
description: 'Optimize your LLM costs while maintaining quality'
---

Routing allows you to sit on the pareto frontier of performance. In other words, by routing, you can get the maximum possible performance at any level of cost. However, the pareto frontier is a curve which means there are many possible points for you to pick. We make it easy to pick the best point for your budget and business needs.

There are two different methods you can use to pick your point on the pareto curve.

<CardGroup cols={2}>
  <Card title="Cost" icon="money-bill">
    Maintain a specified budget for cost while increasing quality as much as possible within that budget.
  </Card>
  <Card title="Quality" icon="star">
    Maintain a specified level of quality while reducing cost as much as possible within that quality constraint.
  </Card>
</CardGroup>

Althought it is slightly counterintuitive, a user who cares about reducing cost as much as possible would want to use the quality parameter while a user who wants to increase quality as much as possible would want to use the cost parameter (and specify a max cost of infinity).

Right away, even with no training data and no judge, Martian can determine what model falls within your cost budget. Cost can be specified in two ways

Either it can be a 
`float` representing a `maximum cost of the request in dollars` 

or 

a `string` representing the `maximum cost of the request being no higher than what that model would have cost`

## Using the Cost Parameter
Add a cost constraint to your router requests:

```python
def translate(text, cost):    
    response = router.completions.create(
        model="translation-router",
        messages=[
            {"role": "system", "content": "You are a skilled Korean-English translator."},
            {"role": "user", "content": text}
        ],
        cost=cost  # Maximum cost for this request
    )
    return response.choices[0].message.content.strip()

# The following result will be sent to the best performing model that costs 5 cents or less
result = translate("안녕하세요", cost=0.05)
# The following result will be sent to the best performing model that costs as much or less than gpt-4o-mini
result = translate("이름이 뭐에요", cost="gpt-4o-mini")
```

## Demonstrating Cost Savings
In this example, we will pretend each request uses roughly the same number of tokens, and we will treat the cost parameter as your maximum per-request budget (in dollars). In reality, token usage and model pricing can vary.

```python
def demonstrate_cost_savings():
    """
    1. Translates several Korean texts, each with a maximum per-request budget.
    2. Compares total cost to a "premium model" single-cost approach.
    3. Prints out translations and the overall cost savings.
    """

    # Example tasks: (Korean text, desired max per-request cost)
    tasks = [
        ("안녕하세요!", 0.003),  # Simple greeting
        ("감사합니다. 주문이 확인되었습니다.", 0.02),  # Email response
        ("서버 구성 방법을 설명해 드리겠습니다.", 0.05),  # Technical doc
        ("본 계약은 법적 구속력이 있습니다.", 0.10),  # Legal content
    ]

    # Suppose if we always used a premium model (like GPT-4),
    # we assume the *average* cost might be around $0.10 per request.
    fixed_model_cost_per_request = 0.10

    results = []
    total_routed_cost = 0.0

    for text, max_cost in tasks:
        translation = translate(text, cost=max_cost)
        results.append((text, translation, max_cost))
        # For demonstration, assume the actual cost is exactly the max cost
        # In a real scenario, it might be less (or vary), depending on usage.
        total_routed_cost += max_cost

    # Calculate the hypothetical fixed-model total
    total_fixed_cost = fixed_model_cost_per_request * len(tasks)

    # Calculate the difference
    savings = total_fixed_cost - total_routed_cost

    # Print out the translations
    for (korean_text, english_text, used_cost) in results:
        print(f"\nKorean: {korean_text}")
        print(f"English Translation: {english_text}")
        print(f"Max Per-Request Cost (Budget): ${used_cost:.3f}")

    # Print out cost comparison
    print("\n====================================")
    print(f"Using a single premium model for all tasks would cost about: "
          f"${total_fixed_cost:.2f}")
    print(f"Routing with per-request budgets costs (approx): "
          f"${total_routed_cost:.2f}")
    print(f"Total savings: ${savings:.2f} for {len(tasks)} translations")
```

<Note>
  Costs of models constantly change and new models are frequently released. Although it is tricky to stay on top of these prices, you're not limited to specific model price points with Martian. You can specify any cost value as your budget and even if there is no model which matches that cost, Martian automatically interpolates between model price points to maximize value.
</Note>